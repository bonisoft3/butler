from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse, HTMLResponse, Response
import asyncio
import logging
from typing import Dict, Any
import os
from agent import call_agent_async, initialize_agent_and_runner
from contextlib import asynccontextmanager
import httpx

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Get message prefix from environment variable or use default
QUERY_PREFIX = os.getenv("QUERY_PREFIX", "ðŸ¤– *butler:*")
WHATSAPP_API_URL = os.getenv("WHATSAPP_API_URL")
WHATSAPP_QR_URL = os.getenv("WHATSAPP_QR_URL")
WHATSAPP_API_KEY = os.getenv("WHATSAPP_API_KEY")

@asynccontextmanager
async def lifespan(app: FastAPI):
    runner, agent  = await initialize_agent_and_runner()
    app.state.runner = runner
    app.state.agent = agent
    logger.info("Agent and runner initialized and stored in app.state.")
    yield
    logger.info("Agent and runner resources closed.")

app = FastAPI(title="WhatsApp Butler Webhook", lifespan=lifespan)
app.state.is_connected = False
async def send_message_to_whatsapp(response: str, chat_id: str):
    """
    Send a message to WhatsApp
    Args:
        response (str): The message to send
        chat_id (str): The chat ID of the message
    """
    # Send the message to the WHATSAPP_API_URL
    async with httpx.AsyncClient() as client:
        await client.post(f"{WHATSAPP_API_URL}/send",
                          headers={"Authorization": f"Bearer {WHATSAPP_API_KEY}"},
                          json={"message": response, "number": chat_id})
    logger.info(f"Message sent to WhatsApp: {response} to {chat_id}")

async def process_message(message: Dict[str, Any]) -> Dict[str, Any]:
    """
    Process incoming WhatsApp message and call agent

    Args:
        message (Dict[str, Any]): The incoming message data

    Returns:
        Dict[str, Any]: Response containing status and agent response
    """
    try:
        # Extract message content
        content = message.get("message", "")
        sender = message.get("name", "")
        chat_id = message.get("from", "")
        has_media = message.get("hasMedia", False)
        media_type = message.get("mediaType", None)
        media_info = message.get("mediaInfo", None)

        # If there's no text content but there's media, inform about the media
        if not content and has_media:
            if media_info:
                if media_type == 'audio':
                    content = f"[Audio received: {media_info.get('filename', 'unknown')}]"
                elif media_type == 'image':
                    content = f"[Image received: {media_info.get('filename', 'unknown')}]"
                else:
                    content = f"[Media downloaded: {media_type} - {media_info.get('filename', 'unknown')}]"
            else:
                if media_type == 'audio':
                    content = "[Audio received]"
                elif media_type == 'image':
                    content = "[Image received]"
                else:
                    content = f"[Media: {media_type}]"
        elif content and has_media:
            if media_info:
                if media_type == 'audio':
                    content = f"{content} [Audio attached: {media_info.get('filename', 'unknown')}]"
                elif media_type == 'image':
                    content = f"{content} [Image attached: {media_info.get('filename', 'unknown')}]"
                else:
                    content = f"{content} [Media attached: {media_type} - {media_info.get('filename', 'unknown')}]"
            else:
                if media_type == 'audio':
                    content = f"{content} [Audio attached]"
                elif media_type == 'image':
                    content = f"{content} [Image attached]"
                else:
                    content = f"{content} [Media attached: {media_type}]"

        if not content:
            return JSONResponse(
                status_code=200,
                content={"status": "success"}
            )

        # Ignore messages generated by the butler itself (to prevent loops)
        if content.startswith(QUERY_PREFIX):
            return JSONResponse(
                status_code=200,
                content={"status": "success"}
            )

        # Process media files to store context, even without query prefix
        if has_media and media_info:
            logger.info(f"Storing media context for {sender} in chat {chat_id}")
            # Store media context by calling agent silently (no response sent)
            runner = app.state.runner
            response = await call_agent_async(f"[MEDIA_CONTEXT_ONLY] {content}", runner, chat_id, chat_id, media_info)
            # Don't send response to WhatsApp for context-only storage
            return JSONResponse(
                status_code=200,
                content={"status": "success"}
            )

        logger.info(f"Processing message from {sender} in chat {chat_id}")

        # Use runner from app.state
        runner = app.state.runner
        response = await call_agent_async(content, runner, chat_id, chat_id, media_info)
        logger.info(f"Agent response: {response}")
        await send_message_to_whatsapp(response, chat_id)
        return JSONResponse(
            status_code=200,
            content={"status": "success"}
        )
    except Exception as e:
        logger.error(f"Error processing message: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/webhook")
async def webhook(request: Request):
    """
    Webhook endpoint for receiving WhatsApp messages

    Args:
        request (Request): The incoming request

    Returns:
        JSONResponse: Response containing status and agent response
    """
    try:
        data = await request.json()
        logger.info(f"Received webhook: {data}")
        await process_message(data)
        return JSONResponse(
            status_code=200,
            content={"status": "success"}
        )
    except Exception as e:
        logger.error(f"Webhook error: {str(e)}")
        return JSONResponse(
            status_code=500,
            content={"status": "error", "error": str(e)}
        )

@app.get("/health")
async def health_check():
    """
    Health check endpoint

    Returns:
        Dict[str, str]: Health status
    """
    return {"status": "healthy"}

@app.get("/connect", response_class=HTMLResponse)
async def connect_page():
    with open("pages/connect.html", "r") as f:
        html_content = f.read()
    return HTMLResponse(content=html_content)

@app.get("/status")
async def get_status(request: Request):
    return JSONResponse({"connected": WHATSAPP_API_KEY})

@app.get("/qrcode")
async def get_qrcode():
    try:
        async with httpx.AsyncClient() as client:
            r = await client.get(WHATSAPP_QR_URL)
            if r.status_code == 200:
                return Response(content=r.content, media_type="image/png")
            return Response(content="QR not found", status_code=404)
    except Exception as e:
        print("QR proxy error:", e)
        return Response(content="QR proxy failed", status_code=500)

@app.post("/set-connected")
async def set_connected(request: Request):
    data = await request.json()
    request.app.state.is_connected = data.get("connected", False)
    return {"message": "Status updated"}

if __name__ == "__main__":
    import uvicorn

    # Get port from environment variable or use default
    port = int(os.getenv("WEBHOOK_PORT", "8080"))

    # Run the server
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=port,
        log_level="info"
    )
